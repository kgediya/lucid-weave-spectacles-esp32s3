<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>LUCID WEAVE // CINEMATIC</title>
  
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;700&display=swap');
    body { margin: 0; overflow: hidden; background: #000000; font-family: 'Rajdhani', sans-serif; color: #fff; cursor: none; }
    
    #ui-layer { transition: opacity 1.5s; opacity: 1; }
    .hidden { opacity: 0 !important; pointer-events: none; }
    
    #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; padding: 40px; box-sizing: border-box; }
    
    .header { display: flex; justify-content: space-between; align-items: center; pointer-events: auto; }
    h1 { 
        margin: 0; font-size: 32px; letter-spacing: 10px; font-weight: 700; text-transform: uppercase; 
        background: linear-gradient(90deg, #9D00FF, #FF0077); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        opacity: 0.8;
    }
    
    .connect-btn { 
        background: rgba(20, 0, 40, 0.6); border: 1px solid #FF0077; color: #FF0077; 
        padding: 12px 50px; font-size: 14px; font-weight: 700; cursor: pointer; border-radius: 4px; 
        transition: 0.5s; letter-spacing: 4px; 
    }
    .connect-btn:hover { background: #FF0077; color: #fff; box-shadow: 0 0 50px #FF0077; }

    .scale-guide-x { position: absolute; bottom: 100px; left: 15%; right: 15%; height: 2px; display: flex; justify-content: space-between; pointer-events: none; background: linear-gradient(90deg, transparent, rgba(157,0,255,0.2), transparent); }
    .note-marker-x { position: relative; width: 1px; height: 15px; background: rgba(255, 0, 119, 0.2); display: flex; flex-direction: column; align-items: center; top: -6px; transform: skewX(-20deg); transition: all 0.5s; }
    .note-marker-x::after { content: attr(data-note); position: absolute; bottom: -30px; font-size: 12px; color: #9D00FF; transition: 0.5s; letter-spacing: 2px; font-weight: 400; transform: skewX(20deg); opacity: 0.7; }
    .note-marker-x.active { background: #FF0077; height: 50px; top: -24px; box-shadow: 0 0 40px #FF0077; width: 2px; }
    .note-marker-x.active::after { color: #fff; font-size: 24px; text-shadow: 0 0 30px #FF0077; bottom: -60px; opacity: 1; }

    .instructions { position: absolute; left: 40px; bottom: 40px; font-size: 10px; color: #444; letter-spacing: 4px; font-weight: 700; text-transform: uppercase; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="ui-layer">
    <div id="scale-overlay-x" class="scale-guide-x"></div>
    <div id="hud">
      <div class="header">
        <h1>LUCID WEAVE</h1>
        <button class="connect-btn" id="btn-connect">ENTER THE VOID</button>
      </div>
    </div>
    <div class="instructions">X: SCALE // Y: RESONANCE // 'F' FULLSCREEN</div>
  </div>

<script>
// --- CONFIG ---
const SUPABASE_URL = "https://ehhntqueiwfbxcvnnbdl.snapcloud.dev";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVoaG50cXVlaXdmYnhjdm5uYmRsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkyMDM5NDQsImV4cCI6MjA4NDc3OTk0NH0.k5kt6OlaeP8dVHlCxQqgr62v62VOw-hXbt55tj8g_YU";
const SARGAM = ["Do", "Re", "Mi", "Fa", "Sol", "La", "Ti", "Do"];
const FREQS  = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25];
const CALIB  = { x: { min: -25, max: 25 }, y: { min: -70, max: 5 }, z: { min: -40, max: -5 } };
const TRAIL_LEN = 80;

// --- GLOBAL STATE ---
const state = {
    right: { x: 0, y: 0, z: 0, active: false, targetX: 0, targetY: 0, targetZ: 0 },
    left:  { x: 0, y: 0, z: 0, active: false, targetX: 0, targetY: 0, targetZ: 0 }
};

// --- SPARKLE TEXTURE ---
function getSparkleTex() {
    const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    // Soft glow white
    const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    grad.addColorStop(0, 'rgba(255,255,255,1)'); 
    grad.addColorStop(0.4, 'rgba(255,255,255,0.2)'); 
    grad.addColorStop(1, 'rgba(0,0,0,0)'); 
    ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
    
    // Hard white core
    ctx.fillStyle = '#ffffff'; 
    ctx.beginPath();
    ctx.arc(32, 32, 8, 0, Math.PI*2);
    ctx.fill();
    return new THREE.CanvasTexture(canvas);
}

// --- SCENE ---
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.012); // Slightly lighter fog for depth
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
camera.position.z = 120;

const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x000000);
document.getElementById('canvas-container').appendChild(renderer.domElement);

const composer = new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene, camera));
// Cinematic Soft Bloom
const bloom = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.8, 0.0);
composer.addPass(bloom);

// --- STARS ---
const starsGeom = new THREE.BufferGeometry();
const starsPos = new Float32Array(2000 * 3);
for(let i=0; i<2000*3; i++) starsPos[i] = (Math.random() - 0.5) * 900;
starsGeom.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
const starsMat = new THREE.PointsMaterial({ color: 0x9D00FF, size: 1.2, transparent: true, opacity: 0.5 });
const stars = new THREE.Points(starsGeom, starsMat);
scene.add(stars);

// --- TRAIL SYSTEM ---
function createTrail(colorHex) {
    const geom = new THREE.BufferGeometry();
    const pos = new Float32Array(TRAIL_LEN * 3);
    const sizes = new Float32Array(TRAIL_LEN);
    geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geom.setAttribute('size', new THREE.BufferAttribute(sizes, 1)); 
    
    const mat = new THREE.PointsMaterial({ 
        size: 30, map: getSparkleTex(), transparent: true, opacity: 0.8,
        blending: THREE.AdditiveBlending, color: new THREE.Color(colorHex), 
        depthWrite: false, sizeAttenuation: true 
    });
    
    const points = new THREE.Points(geom, mat);
    const buffer = new Float32Array(TRAIL_LEN * 3).fill(-2000); 
    return { points, buffer, head: 0 };
}

const rTrail = createTrail(0xFF0077); 
const lTrail = createTrail(0x9D00FF);
scene.add(rTrail.points); scene.add(lTrail.points);

function updateTrailLogic(trail, x, y, z, active) {
    const idx = trail.head * 3;
    trail.buffer[idx] = x;
    trail.buffer[idx+1] = y;
    trail.buffer[idx+2] = z;
    trail.head = (trail.head + 1) % TRAIL_LEN;

    const posAttr = trail.points.geometry.attributes.position.array;
    const sizeAttr = trail.points.geometry.attributes.size.array;
    
    for(let i=0; i<TRAIL_LEN; i++) {
        const readIdx = (trail.head - 1 - i + TRAIL_LEN) % TRAIL_LEN;
        const bufIdx = readIdx * 3;
        
        posAttr[i*3]   = trail.buffer[bufIdx];
        posAttr[i*3+1] = trail.buffer[bufIdx+1];
        posAttr[i*3+2] = trail.buffer[bufIdx+2];

        let zDepth = trail.buffer[bufIdx+2];
        let zScale = 1 + (Math.abs(zDepth) / 50); // Softer depth scaling
        let ageFactor = Math.pow(1.0 - (i / TRAIL_LEN), 1.5); // Smooth fade out
        
        let s = ageFactor * 40 * zScale;
        if(!active) s *= 0.94; 
        sizeAttr[i] = s;
    }
    
    trail.points.geometry.attributes.position.needsUpdate = true;
    trail.points.geometry.attributes.size.needsUpdate = true;
}

// --- AUDIO ---
let audioCtx = null; let rVoice, lVoice;
class LucidSynth {
    constructor(ctx, dest) {
        this.ctx = ctx; this.out = ctx.createGain(); this.out.gain.value = 0; this.out.connect(dest);
        this.osc = ctx.createOscillator(); this.osc.type = "sine";
        this.fm = ctx.createOscillator(); this.fm.type = "sine";
        this.fmg = ctx.createGain();
        this.fm.connect(this.fmg); this.fmg.connect(this.osc.frequency);
        this.osc.connect(this.out); this.osc.start(); this.fm.start();
    }
    update(f, v, res, t) {
        this.osc.frequency.setTargetAtTime(f, t, 0.2); // Slower glide
        this.fm.frequency.setTargetAtTime(f * 2, t, 0.2);
        this.fmg.gain.setTargetAtTime(res * 800, t, 0.2);
        this.out.gain.setTargetAtTime(v * 0.4, t, 0.2);
    }
}
function initAudio() {
    audioCtx = new AudioContext();
    const master = audioCtx.createGain(); master.connect(audioCtx.destination);
    const d = audioCtx.createDelay(); d.delayTime.value=0.5; // Longer delay
    const f = audioCtx.createGain(); f.gain.value=0.4;
    d.connect(f); f.connect(d); master.connect(d); d.connect(audioCtx.destination);
    rVoice = new LucidSynth(audioCtx, master); lVoice = new LucidSynth(audioCtx, master);
}

// --- UTILS ---
function normalize(val, min, max) { return Math.max(0, Math.min(1, (val - min) / (max - min))); }

// --- NETWORK HANDLER ---
document.getElementById('btn-connect').onclick = () => {
    initAudio();
    const client = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    client.channel('air-music').on('broadcast', { event: 'controls' }, ({ payload }) => {
        const r = payload.right || {};
        const l = payload.left || {};
        
        if (r.tracked) {
            state.right.active = true;
            state.right.targetX = (r.wrist||[0,0,0])[0];
            state.right.targetY = (r.wrist||[0,0,0])[1];
            state.right.targetZ = (r.wrist||[0,0,0])[2];
        } else {
            state.right.active = false;
        }

        if (l.tracked) {
            state.left.active = true;
            state.left.targetX = (l.wrist||[0,0,0])[0];
            state.left.targetY = (l.wrist||[0,0,0])[1];
            state.left.targetZ = (l.wrist||[0,0,0])[2];
        } else {
            state.left.active = false;
        }

    }).subscribe();
    document.getElementById('btn-connect').style.display = 'none';
};

// --- RENDER LOOP ---
const camTarget = new THREE.Vector3(0,0,120);

function animate() { 
    requestAnimationFrame(animate); 
    
    // 1. HAND INTERPOLATION (0.15 is good for responsiveness vs smooth)
    if(state.right.active) {
        state.right.x += (state.right.targetX - state.right.x) * 0.15;
        state.right.y += (state.right.targetY - state.right.y) * 0.15;
        state.right.z += (state.right.targetZ - state.right.z) * 0.15;
    } else {
        state.right.y += 0.1;
        state.right.x += Math.sin(Date.now()*0.001) * 0.2;
    }

    if(state.left.active) {
        state.left.x += (state.left.targetX - state.left.x) * 0.15;
        state.left.y += (state.left.targetY - state.left.y) * 0.15;
        state.left.z += (state.left.targetZ - state.left.z) * 0.15;
    } else {
        state.left.y += 0.1;
    }

    updateTrailLogic(rTrail, state.right.x, state.right.y, state.right.z, state.right.active);
    updateTrailLogic(lTrail, state.left.x, state.left.y, state.left.z, state.left.active);

    // Audio Update
    if(audioCtx && state.right.active) {
        const nx = normalize(state.right.x, CALIB.x.min, CALIB.x.max);
        const fIdx = Math.floor(nx * (SARGAM.length-1));
        const ny = normalize(state.right.y, CALIB.y.min, CALIB.y.max);
        rVoice.update(FREQS[fIdx], 0.8, ny, audioCtx.currentTime);
        document.querySelectorAll('.note-marker-x').forEach(m => m.classList.remove('active'));
        document.getElementById(`note-${fIdx}`)?.classList.add('active');
    } else if (audioCtx) {
        rVoice.update(220, 0, 0, audioCtx.currentTime);
    }
    
    if(audioCtx && state.left.active) {
        lVoice.update(FREQS[0]/2, 0.5, 0.5, audioCtx.currentTime);
    } else if(audioCtx) {
        lVoice.update(110, 0, 0, audioCtx.currentTime);
    }

    // 2. SLOW CINEMATIC CAMERA
    if (state.right.active) {
        // Wider multiplier for bigger, slower sweeps
        camTarget.set(
            state.right.x * 2.0, 
            state.right.y * 2.0, 
            120 + (state.right.z * 1.5)
        );
    } else {
        camTarget.set(0, 0, 120);
    }

    // LERP 0.01 = HEAVY / DREAMY / SMOOTH
    camera.position.lerp(camTarget, 0.01);
    
    // Very subtle banking
    const bankAngle = -camera.position.x * 0.002;
    camera.rotation.z += (bankAngle - camera.rotation.z) * 0.02;
    
    // Soft look-ahead
    camera.lookAt(camera.position.x * 0.1, camera.position.y * 0.1, 0);

    stars.rotation.z += 0.0002;

    composer.render(); 
}

// --- CONTROLS ---
const sMap = ["Do", "Re", "Mi", "Fa", "Sol", "La", "Ti", "Do"];
const scaleOverlay = document.getElementById('scale-overlay-x');
sMap.forEach((n, i) => {
    const d = document.createElement('div'); d.className = 'note-marker-x'; d.id = `note-${i}`; d.setAttribute('data-note', n);
    scaleOverlay.appendChild(d);
});

document.addEventListener('keydown', (e) => {
    if(e.key.toLowerCase() === 'f') {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else if (document.exitFullscreen) document.exitFullscreen();
    }
});

animate();
window.onresize = () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
</script>
</body>
</html>